# On Persistence

  * Author: Philippe Collet

We focus here on a first version of the persistence layer using a H2 in-memory database.

## Configuration

We have to change the pom.xml: 

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId> <!-- JPA + hibernate-core default support -->
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <version>2.1.210</version>
        </dependency>
```

We have to add a configuration class to configure a DataSource:

```java
@Configuration
@PropertySource("classpath:persistence-h2.properties")
public class PersistenceJpaConfig {

    private static final Logger LOG = LoggerFactory.getLogger(PersistenceJpaConfig.class);

    @Autowired
    private Environment env;

    @Bean
    public DataSource dataSource() {
        final DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(env.getProperty("jdbc.driverClassName"));
        dataSource.setUrl(env.getProperty("jdbc.url"));
        dataSource.setUsername(env.getProperty("jdbc.user"));
        dataSource.setPassword(env.getProperty("jdbc.pass"));
        LOG.info("TCFS:H2 Data-source initialized at url " + dataSource.getUrl());
        return dataSource;
    }

}
```

and we have to add a new properties file in the `resources` directory:

```
# jdbc.X
jdbc.driverClassName=org.h2.Driver
jdbc.url=jdbc:h2:mem:db;DB_CLOSE_DELAY=-1
jdbc.user=sa
jdbc.pass=

# H2 in-memory DB
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.url=jdbc:h2:mem:db;DB_CLOSE_DELAY=-1
spring.jpa.database-platform: org.hibernate.dialect.H2Dialect
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.h2.console.enabled=true
spring.h2.console.path=/console/
```

The JPA and H2 configuration enables one to see SQL queries generated on all JPA calls on the console, while a web console for the H2 DB is available at [http://localhost:8080/console/](http://localhost:8080/console/) while the backend is running.

## Annotating Classes to create Entities

Now, our technical setup is complete, once and for all. We can focus on the business part, _i.e._, storing cookies, customers and related orders. 

JPA Entities are simple POJO with annotations. Excepting that the annotations here are related to persistence instead of functional concerns. And that entities needs a little bit more than simple annotations:

  * An empty constructor
  * A proper `equals` method that relies on business items 
  * a proper `hashCode` method to support objects identification in JPA caches. 

The equals and hashCode methods must relies on so-called _business keys_. It is extremely dangerous (and an hideous abstraction leak) to rely at the application level on elements generated by the database layer: you are losing control on object uniqueness. As a consequence, you must be able to define how two entities are equals from a business point of view (the architectural level), and not a technical one (the database one). 

### Persisting Items

An Item does not exists by itself: it is part of a given cart, or a given order. As a consequence, it is an `Embeddable` entity. Its associated cookie is based on an enumeration, and thus declared as an `Enumerated` property. For clarity and log purposes, we prefer to use string literals (the cookie's name) instead of ordinals (the cookie's index in the enum) at the persistence level. The quantity cannot be null, so we simply add a validation constraint that will prevent to persist an entity with a null quantity of cookies. The cookie cannot be null too, so we use the same kind of constraints.

```java
@Embeddable
public class Item {

    @Enumerated(EnumType.STRING)
    @NotNull
    private Cookies cookie;

    @NotNull
    private int quantity;
	
	//...
}
``` 

### Persisting Orders

The previously defined `Order` class relies on plain java UUIDs to identify orders among others. UUIDs are not part of the JPA specification, and cannot be used directly. We go here for the the JPA solution, _i.e._, altering our data model to store ids as Longs instead of strings. 

  * The `id` field is the refactored as a Long;
  * The `orderStatus` field refers to an enumerated, this is the very same situation than the one encountered before for the cookie stored inside an item;
  * The `customer` attribute refers to another entity, and considering that _(i)_ an order will belong to a single customer and _(ii)_ a customer will hopefully make multiple orders, we annotate this attribute as a `ManyToOne`: _many_ orders related to _one_ single customer;
  * The `items` field is a collection of elements that cannot exists by themselves (as we defined an Item as an embeddable entity). We use the brand new `ElementCollection` annotation (available since JPA 2.0) that implement this intention.

We are still encountering a big issue. The `Order` class will be, like the others, automatically translated by OpenJPA into a SQL entity, _i.e._, a table named `ORDER`. You're not seeing the point? Imagine the query that will select the data associated to a given customer, and order her orders based on their status. Seeing it? Ordering the orders? `ORDER` is a SQL keyword, and thus cannot be used as a regular identifier! We need to adapt the way JPA will map the name, using the `@Table` annotation.

```java
@Entity
@Table(name= "orders")
public class Order {

    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    @NotNull
    private Customer customer;

    @ElementCollection
    private Set<Item> items;

    @Enumerated(EnumType.STRING)
    private OrderStatus status;
	
	// ...
}
```


### Persisting Customers

Customers were previously identified by their name. This is not reasonable anymore, so we add a primary key field to ensure better unicity. With respect to the other fields:

  * The `name` cannot be blank;
  * The `creditCard` follows a regular pattern that we should verify to avoid storing inconsistent data. The pattern is defined as a regular expression (10 digits, _i.e._, `\\d{10}+` in java words);
  * The `orders` field is actually the counterpart of the `customer` one in the `Order` entity. As a consequence it is defined as a `OneToMany` relationship: _one_ customer is linked to _many_ orders. As the customer is the owner of the orders, it defines the `mappedBy` attribute needed to ensure the bidirectional relationship.

```java
@Entity
public class Customer {

    @Id
    @GeneratedValue
    private Long id;

    @NotBlank
    @Column(unique = true)
    private String name;

    @Pattern(regexp = "\\d{10}+", message = "Invalid creditCardNumber")
    private String creditCard;

    @OneToMany(cascade = {CascadeType.REMOVE}, fetch = FetchType.LAZY, mappedBy = "customer")
    private Set<Order> orders = new HashSet<>();

    @ElementCollection
    private Set<Item> cart = new HashSet<>();

	// ...
}
```  


## Repositories

We rely here on the Spring Data repostorties for Customers and Orders:

```java
@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    Optional<Customer> findCustomerByName(String name);
}

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
}
```  

We can then use them by injection to implement the Kitchen with `save` and `findbById` being generated by SpringData into an implementation of the repository interface.

```java
@Component
@Transactional
public class Kitchen implements OrderProcessing, Tracker {

    @Autowired
    private OrderRepository orderRepository;

    @Override
    public void process(Order order) {
        order.setStatus(OrderStatus.IN_PROGRESS);
        orderRepository.save(order);
    }

    @Override
    public OrderStatus retrieveStatus(long orderId) throws UnknownOrderId {
        Optional<Order> order = orderRepository.findById(orderId);
        if (order.isEmpty())
            throw new UnknownOrderId(orderId);
        return  order.get().getStatus();
    }
``` 
